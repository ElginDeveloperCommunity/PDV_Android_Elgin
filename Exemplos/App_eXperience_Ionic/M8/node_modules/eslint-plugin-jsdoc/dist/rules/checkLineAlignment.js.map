{"version":3,"sources":["../../src/rules/checkLineAlignment.js"],"names":["matchAll","string","regexp","callback","limit","result","index","exec","getFullDescription","lineString","getExpectedPositions","partsMaxLength","indentLevel","reduce","acc","cur","isNotAligned","expectedPositions","partsMatrix","some","line","position","partIndex","createFixer","comment","lineRegExp","tagIndentation","fixer","lineIndex","fixed","value","replace","spacings","repeat","length","replaceText","checkCommentPerTag","tag","report","RegExp","lines","match","forEach","partLength","maxLength","jsdocNode","context","indent","options","iterateAllJsdocs","meta","docs","description","url","fixable","schema","enum","type"],"mappings":"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","sourcesContent":["import {\n  set,\n} from 'lodash';\nimport iterateJsdoc from '../iterateJsdoc';\n\n/**\n * Aux method until we consider the dev envs support `String.prototype.matchAll` (Node 12+).\n *\n * @param {string}   string   String that will be checked.\n * @param {RegExp}   regexp   Regular expression to run.\n * @param {Function} callback Function to be called each iteration.\n * @param {int}      limit    Limit of matches that we want to exec.\n *\n * @todo [engine:node@>=12]: Remove function and use `String.prototype.matchAll` instead.\n */\nconst matchAll = (string, regexp, callback, limit) => {\n  let result;\n  let index = 0;\n\n  while ((result = regexp.exec(string)) && index <= limit - 1) {\n    // eslint-disable-next-line promise/prefer-await-to-callbacks\n    callback(result, index++);\n  }\n};\n\n/**\n * Get the full description from a line.\n *\n * @param {string} lineString The line string.\n *\n * @returns {string} The full description.\n */\nconst getFullDescription = (lineString) => {\n  return /(?:\\S+\\s+){4}(.*)/.exec(lineString)[1];\n};\n\n/**\n * Get the expected positions for each part.\n *\n * @param {int[]} partsMaxLength Max length of each part.\n * @param {int}   indentLevel    JSDoc indent level.\n *\n * @returns {int[]} Expected position for each part.\n */\nconst getExpectedPositions = (partsMaxLength, indentLevel) => {\n  // eslint-disable-next-line unicorn/no-reduce\n  return partsMaxLength.reduce(\n    (acc, cur, index) => {\n      return [...acc, cur + acc[index] + 1];\n    },\n    [indentLevel],\n  );\n};\n\n/**\n * Check is not aligned.\n *\n * @param {int[]}   expectedPositions Expected position for each part.\n * @param {Array[]} partsMatrix       Parts matrix.\n *\n * @returns {boolean}\n */\nconst isNotAligned = (expectedPositions, partsMatrix) => {\n  return partsMatrix.some((line) => {\n    return line.some(\n      ({position}, partIndex) => {\n        return position !== expectedPositions[partIndex];\n      },\n    );\n  });\n};\n\n/**\n * Fix function creator for the report. It creates a function which fix\n * the JSDoc with the correct alignment.\n *\n * @param {object}  comment           Comment node.\n * @param {int[]}   expectedPositions Array with the expected positions.\n * @param {Array[]} partsMatrix       Parts matrix.\n * @param {RegExp}  lineRegExp        Line regular expression.\n * @param {string}  tagIndentation    Tag indentation.\n *\n * @returns {Function} Function which fixes the JSDoc alignment.\n */\nconst createFixer = (comment, expectedPositions, partsMatrix, lineRegExp, tagIndentation) => {\n  return (fixer) => {\n    let lineIndex = 0;\n\n    // Replace every line with the correct spacings.\n    const fixed = comment.value.replace(lineRegExp, () => {\n      // eslint-disable-next-line unicorn/no-reduce\n      return partsMatrix[lineIndex++].reduce(\n        (acc, {string}, index) => {\n          const spacings = ' '.repeat(expectedPositions[index] - acc.length);\n\n          return acc + (index === 0 ? tagIndentation : spacings) + string;\n        },\n        '',\n      );\n    });\n\n    return fixer.replaceText(comment, '/*' + fixed + '*/');\n  };\n};\n\n/**\n * Check comment per tag.\n *\n * @param {object}   comment        Comment node.\n * @param {string}   tag            Tag string.\n * @param {string}   tagIndentation Tag indentation.\n * @param {Function} report         Report function.\n */\nconst checkCommentPerTag = (comment, tag, tagIndentation, report) => {\n  const lineRegExp = new RegExp(`.*@${tag}[\\\\s].*`, 'gm');\n  const lines = comment.value.match(lineRegExp);\n\n  if (!lines) {\n    return;\n  }\n\n  /**\n   * A matrix containing the current position and the string of each part for each line.\n   * 0 - Asterisk.\n   * 1 - Tag.\n   * 2 - Type.\n   * 3 - Variable name.\n   * 4 - Description (Optional).\n   */\n  const partsMatrix = [];\n\n  /**\n   * The max length of each part, comparing all the lines.\n   */\n  const partsMaxLength = [];\n\n  // Loop (lines x parts) to populate partsMatrix and partsMaxLength.\n  lines.forEach((lineString, lineIndex) => {\n    // All line parts until the first word of the description (if description exists).\n    matchAll(\n      lineString,\n      /\\S+/g,\n      ({0: match, index: position}, partIndex) => {\n        set(partsMatrix, [lineIndex, partIndex], {\n          position,\n          string: partIndex === 4 ? getFullDescription(lineString) : match,\n        });\n\n        const partLength = match.length;\n        const maxLength = partsMaxLength[partIndex];\n\n        partsMaxLength[partIndex] = maxLength > partLength ? maxLength : partLength;\n      },\n      5,\n    );\n  });\n\n  const expectedPositions = getExpectedPositions(partsMaxLength, tagIndentation.length);\n\n  if (isNotAligned(expectedPositions, partsMatrix)) {\n    report(\n      'Expected JSDoc block lines to be aligned.',\n      createFixer(\n        comment,\n        expectedPositions,\n        partsMatrix,\n        lineRegExp,\n        tagIndentation,\n      ),\n    );\n  }\n};\n\nexport default iterateJsdoc(({\n  jsdocNode,\n  report,\n  context,\n  indent,\n}) => {\n  if (context.options[0] === 'never') {\n    report('The `never` option is not yet implemented for this rule.');\n\n    return;\n  }\n\n  if (context.options[0] !== 'always') {\n    return;\n  }\n\n  // `indent` is whitespace from line 1 (`/**`), so slice and account for \"/\".\n  const tagIndentation = indent + ' ';\n\n  ['param', 'arg', 'argument', 'property', 'prop'].forEach((tag) => {\n    checkCommentPerTag(jsdocNode, tag, tagIndentation, report);\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid alignment of JSDoc block lines.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-check-line-alignment',\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"file":"checkLineAlignment.js"}